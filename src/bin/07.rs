use std::path::PathBuf;

use hashbrown::HashMap;

type FileStructure<'a> = HashMap<PathBuf, Vec<(u32, &'a str)>>;
type DirSizes = HashMap<PathBuf, u32>;

#[aoc::main(07)]
fn main(input: &str) -> (u32, u32) {
    let mut file_structure: FileStructure = HashMap::new();
    let mut current_dir = PathBuf::new();

    // Skip to avoid first "" generated by split first line
    input.split("$ ").skip(1).for_each(|l| {
        let cmd = l.lines().next().unwrap();
        match cmd {
            "ls" => {
                let action: Vec<(u32, &str)> = l
                    .lines()
                    .skip(1)
                    .map(|l| {
                        let (x, f) = l.split_once(' ').unwrap();
                        // Directories does not have size, they have "dir" word
                        // Using unwrap_or gives directories size 0 to differentiate from files
                        (x.parse().unwrap_or(0), f)
                    })
                    .collect();

                file_structure.insert(current_dir.clone(), action);
            }
            "cd .." => {
                // Removed last directory from path
                current_dir.pop();
            }
            // only cd directory case left
            _ => {
                // Push new directory to path
                current_dir.push(cmd.split_once(' ').unwrap().1);
            }
        }
    });

    let mut directory_sizes: DirSizes = HashMap::new();
    file_structure.keys().for_each(|dir| {
        calculate_directory_sizes(dir, &file_structure, &mut directory_sizes);
    });

    (part1(&directory_sizes), part2(&directory_sizes))
}

fn part1(dir_sizes: &DirSizes) -> u32 {
    dir_sizes.values().filter(|&&s| s <= 100000).sum()
}

fn part2(dir_sizes: &DirSizes) -> u32 {
    let total_size = dir_sizes.get(&PathBuf::from("/")).unwrap().to_owned();

    dir_sizes
        .values()
        .filter(|&&s| s >= total_size - 40000000)
        .min()
        .unwrap()
        .to_owned()
}

fn calculate_directory_sizes(dir: &PathBuf, fs: &FileStructure, dir_sizes: &mut DirSizes) {
    // Duplicated folders, reduce calculations
    // 40% reduced total time checking if folder exists o_O
    if dir_sizes.contains_key(dir) {
        return;
    }

    let directory_size = fs[dir]
        .iter()
        .map(|&(s, d)| match s {
            // Recursive calculation of sub folders size
            0 => {
                let dir = dir.join(d);
                calculate_directory_sizes(&dir, fs, dir_sizes);
                dir_sizes[&dir]
            }
            // File size
            s => s,
        })
        .sum();

    dir_sizes.insert(dir.clone(), directory_size);
}
